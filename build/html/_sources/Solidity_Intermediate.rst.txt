Solidity - Intermediate level
+++++++++++++++++++++++++++++

Storage Factory Example
-----------------------

Implemeting the storage factory
===============================

- Let's say now that we want to execute a contract from another contract that is written in another file. For this we use import. To illustrate this, we're gonna create a simple storage smart contract to store people by name and age and map their names to their ages and then create another contract that executes this contract.

* Simple storage contract

.. code-block:: solidity

	pragma solidity >=0.6.0 <0.9.0;
	
	contract SimpleStorage {
		
		// We will define two functions for later use
		// one to store a number and one to retrieve it
		
		uint256 favNumber;
		
		function store(uint256 _number) public {
			favNumber = _number;
		}
		
		function retrieve() public view returns(uint256) {
			return favNumber;
		}
		
		struct People {
			string name;
			uint age;			
		}
		
		People[] public people;
		mapping(string => uint256) public nameToAge;
		
		function addPerson(string memory _name, uint256 _age) public {
			people.push(People({name:_name, age:_age}));
			nameToAge[_name] = _age;
		}
	}

- This smart contract is saved to a file called SimpleStorage.sol
	
- Now we're gonna create another smart contract. In this smart contract, we're gonna simply import our SimpleStorage smart contract.

.. code-block:: solidity

	pragma solidity >=0.6.0 <0.9.0;
	
	import "./SimpleStorage.sol";

	contract StorageFactory {

	}

- This way, we can see in REMIX that we can either deploy the imported smart contract (SimpleStorage) or the empty one (StorageFactory).

- What we wanna do is deploying the SimpleStorage smart contract from the StorageFactory smart contract. Hence, we have to create a function for that.

.. code-block:: solidity

	pragma solidity >=0.6.0 <0.9.0;
	
	import "./SimpleStorage.sol";

	contract StorageFactory {
		function createSimpleStorageContract() public {
			// We define a new variable of type SimpleStorage contract with a name (for example simpleStorage):
			SimpleStorage simpleStorage = new SimpleStorage();
		}
	}

- Using these few lines of code, we are able to deploy a smart contract from another smart contract. The only remaining issue is that, using REMIX IDE for example with a javascript VM will show us that the contracts have been created and deployed but we can't really read where those contracts are being created (Unlike if we we're using a real network or a testnet, in this case, we can see our contracts on etherscan). To keep track of the SimpleStorage contract that we've deployed, we can use an array..



.. code-block:: solidity

	//SPDX-License-Identifier: MIT
	pragma solidity >=0.6.0 <0.9.0;

	import "./SimpleStorage.sol";

	contract StorageFactory {
		
		// To keep track of created contracts
		// using REMIX IDE VM
		SimpleStorage[] public simpleStorageArray;
		
		function createSimpleStorageContract() public {
			// We define a new variable of type SimpleStorage contract with a name (for example simpleStorage):
			SimpleStorage simpleStorage = new SimpleStorage();
		
			// To keep track of created contracts
			// using REMIX IDE VM
			simpleStorageArray.push(simpleStorage);
		}	
	}

- If we run this code snippet in a REMIX IDE with a JavaScript VM environement for example, we're gonna get for each smart contract created by the `createSimpleStorageContract` an adress that the corresponding contract was deployed to. This way, we deployed a contract to the blockchain from another contract.

.. NOTE::

	- We should always think of starting our code with a license identifier : **SPDX-License-Identifier: MIT**
	
- What we want to do in the next step is to call the function that are defined in the internal contract from the new contract. To achieve this, we have to create functions in our new contract to call other functions that are originally defined in the contract deployed contract. 

.. HINT::

	- To interact with a contract, we need two things; the adress of the contract we want to interact with and the ABI (Application Binary Interface).
	- Since we are storing our deployed contracts in an array, each contract can be pointed to by its index in the array and we can interact with it through its adress.

.. code-block:: solidity

	// SPDX-License-Identifier: MIT

	pragma solidity ^0.6.0;

	import "./SimpleStorage.sol";

	contract StorageFactory {

		SimpleStorage[] public simpleStorageArray;

		function createSimpleStorageContract() public {
			SimpleStorage simpleStorage = new SimpleStorage();
			simpleStorageArray.push(simpleStorage);
		}

		// Function to call Store function of SimpleStorage
		// we need to pass an index to point to a deployed contract in 		
		// the array where all deployed contracts are (simpleStorageArray)
		// We will also pass a number to be stored as required by
		// the SimpleStorage store function
		function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {
			// We can get the adress of a contract through the
			// function adress(your_contract)
			// We create simpleStorage object that we can use to
			// call any function in the SimpleStorage contract	
			SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));	
			simpleStorage.store(_simpleStorageNumber);
		}

		function sfRetrieve(uint256 _simpleStorageIndex) public view returns(uint256) {
			SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));
			return simpleStorage.retrieve();
		}
	}

Inheritance
===========

- So far, all looks good, but what if we had too many functions inside SimpleStorage contract and we wanted to use all of them inside our StorageFactory ? 

- Inheritance solves this problem: StorageFactory can inherit all the functions of SimpleStorage.

- In solidity, we simply define our StorageFactory to be of "contract" SimpleStorage. (similar to saying of "type" or of "class" in any other programming language). To do so, we use **is** ``contract StorageFactory is SimpleStorage { // lines-of-code; }``. This is enough to have all the functions that are defined in SimpleStorage imported in the StorageFactory and ready to be used.

- The code becomes;

.. code-block:: solidity

	// SPDX-License-Identifier: MIT

	pragma solidity ^0.6.0;

	import "./SimpleStorage.sol";

	contract StorageFactory is SimpleStorage{

		SimpleStorage[] public simpleStorageArray;

		function createSimpleStorageContract() public {
			SimpleStorage simpleStorage = new SimpleStorage();
			simpleStorageArray.push(simpleStorage);
		}

		// Function to call Store function of SimpleStorage
		// we need to pass an index to point to a deployed contract in 		
		// the array where all deployed contracts are (simpleStorageArray)
		// We will also pass a number to be stored as required by
		// the SimpleStorage store function
		function sfStore(uint256 _simpleStorageIndex, uint256 _simpleStorageNumber) public {
			// We can get the adress of a contract through the
			// function adress(your_contract)
			// We create simpleStorage object that we can use to
			// call any function in the SimpleStorage contract	
			SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));	
			simpleStorage.store(_simpleStorageNumber);
		}

		function sfRetrieve(uint256 _simpleStorageIndex) public view returns(uint256) {
			SimpleStorage simpleStorage = SimpleStorage(address(simpleStorageArray[_simpleStorageIndex]));
			return simpleStorage.retrieve();

		}

	}

- **That was all for the storage example.**

Fund Me
-------

A simple function to fund your smart contract
=============================================

- In case we want to create payable functions, we should use the keyword ``payable``.

- The code below is a simple implementation of a payable function.

.. code-block:: solidity

	// SPDX-Licence-Identifier: MIT

	pragma solidity ^0.6.0;

	contract FundMe {

		function fund() public payable {
		}
	}

- Let's say for example that we want to keep track of who sent us funding using this contract: To do so, we can create a mapping between adresses and value.

.. code-block:: solidity

	// SPDX-Licence-Identifier: MIT

	pragma solidity ^0.6.0;

	contract FundMe {

		mapping(address => uint256) public adressToAmountFunded;
		function fund() public payable {
			// msg.sender is the sender of the function call.
			// msg.value is how much they sent.
		    // += to cumulate the amounts sent
		    adressToAmountFunded[msg.sender] += msg.value;
		}
	}

Getting external data with chainlink
====================================













